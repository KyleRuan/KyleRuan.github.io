<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="kyleruan"><title>the swift programming language swift 4.2 读书笔记 · Dev && Football</title><meta name="description" content="最近要给组内同事分享Swift入门基础，想到也就苹果官方的教程算是比较经典，而swift一个版本一个大变，所以研读了基于最新swift4.2的《the swift programming language swift》。以下按照书籍的目录顺序给大家讲一下。针对从未接触过Swift的开发写的，小白版本"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dev &amp;&amp; Football</a></h3><div class="description"><p>iOS Developer fullstack Blog</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>the swift programming language swift 4.2 读书笔记</a></h3></div><div class="post-content"><p> 最近要给组内同事分享Swift入门基础，想到也就苹果官方的教程算是比较经典，而swift一个版本一个大变，所以研读了基于最新swift4.2的《the swift programming language swift》。以下按照书籍的目录顺序给大家讲一下。针对从未接触过Swift的开发写的，小白版本教程</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>一上来就是平时开发一直在用的类型<code>String</code>。<strong><em>字符串是值类型</em></strong>，所以你<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var 来标记变量，用 let 来表示常量。</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">"Hello,Swift"</span></span><br><span class="line">str = str2</span><br><span class="line">str = <span class="string">"www"</span> <span class="comment">// 你对str 的更改不会影响str2</span></span><br><span class="line"><span class="comment">// """ 来表示多行</span></span><br><span class="line"><span class="keyword">let</span> linesStr = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">one line</span></span><br><span class="line"><span class="string">two line</span></span><br><span class="line"><span class="string">three line</span></span><br><span class="line"><span class="string"><span class="subst">\(conbineStr)</span></span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure></p>
<h3 id="String-的常用方法"><a href="#String-的常用方法" class="headerlink" title="String 的常用方法"></a>String 的常用方法</h3><p><code>String</code> 遵循<code>StringProtocol</code>协议，这样让他能够被遍历<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> str &#123;</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h4><p>在oc代码里，字符串的类型是<code>NSString</code>，我们通常通过<code>substring</code>的方法来获取到字符串<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nsStr = <span class="type">NSString</span>()</span><br><span class="line">nsStr = <span class="string">"I am a NSString"</span></span><br><span class="line"><span class="keyword">let</span> subString = nsStr.substring(with: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">12</span>))</span><br></pre></td></tr></table></figure></p>
<p>但是<code>String</code> 类型没有类似的<code>substring</code>方法，主要原因是<code>String</code>类型其实没有Range的概念，也就说通过Range是获取不到subString的。 那么我们怎么获取子字符串呢？ 有如下三种方法：</p>
<ol>
<li>将<code>String</code>转换成<code>NSString</code></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aStr = <span class="string">"a swift string"</span></span><br><span class="line"><span class="keyword">let</span> str = ((aStr <span class="keyword">as</span> <span class="type">NSString</span>).substring(from: <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li><code>String</code>对象自有的Range属性String.Index<br>每个<code>String</code>实例 都有一个startIndex和aStr.endIndex 标记了String的范围<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indS = aStr[aStr.startIndex..&lt;aStr.endIndex]</span><br><span class="line">``` </span><br><span class="line">对于任意位置，可以设置偏移量来取值,比如我想要取从第二个字符开始，到字符串结尾，那么需要先取到的第二个字符串的<span class="type">Index</span></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">let</span> stridx = aStr.index(aStr.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> indS = aStr[stridx..&lt;aStr.endIndex]</span><br><span class="line">``` </span><br><span class="line"><span class="type">String</span>还提供了其他一些其他的获取index的方式</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">aStr.index(after: aStr.startIndex)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果只是取开始的前几个，或者结尾的几个字符的话还有两个简单的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aStr.<span class="keyword">prefix</span>(<span class="number">6</span>) <span class="comment">// 取前6个字符</span></span><br><span class="line">aStr.suffix(<span class="number">6</span>) <span class="comment">// 取后6个字符</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通过上诉方式得到的subString 类型其实是<code>Substring</code>而不是<code>String</code>，两者都遵循<code>StringProtocol</code>协议，使用上没有区别。官方文档给的解释是每一个子字符串都有一块内存区域用来保存组成子字符串的字符。字符串与子字符串的不同之处在于，作为性能上的优化，子字符串可以重用一部分用来保存原字符串的内存，或者是用来保存其他子字符串的内存。（字符串也拥有类似的优化，但是如果两个字符串使用相同的内存，他们就是等价的。）这个性能优化意味着在你修改字符串或者子字符串之前都不需要花费拷贝内存的代价。如同上面所说的，子字符串并不适合长期保存——因为它们重用了原字符串的内存，只要这个字符串有子字符串在使用中，那么这个字符串就必须一直保存在内存里。</p>
</blockquote>
<p><img src="/images/15320961892382.jpg" alt=""></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>Swift 的<code>Array</code>也是一个值类型。相比<code>NSArray</code>，<code>Array</code>则有更加现代的用法，大量的函数式编程思想，<code>map</code>,<code>filter</code>,<code>forEach</code>等等。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合的key，都必须是可哈希的，且每个元素都是唯一的。提供了很多数学集合的概念，比如交集，差集等等，对于过滤数据来说很有用。比如<br><img src="/images/Screen%20Shot%202018-07-23%20at%2010.59.50%20PM.png" alt="Set 函数"></p>
<h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary<key, value=""></key,></h3><p>就是标准意思上的键值对，Key必须是可哈希的。定义字典的方式也很多</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//method1</span></span><br><span class="line"> <span class="keyword">var</span> airports = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br><span class="line"> <span class="comment">//method2</span></span><br><span class="line"> <span class="keyword">var</span> airports:[<span class="type">String</span>:<span class="type">Int</span>] = [:]</span><br><span class="line"> <span class="comment">//method3</span></span><br><span class="line"> <span class="keyword">var</span> airports = [<span class="type">String</span>:<span class="type">Int</span>]()</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="支持函数重载"><a href="#支持函数重载" class="headerlink" title="支持函数重载"></a>支持函数重载</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + person + <span class="string">"!"</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">"Hello: <span class="subst">\(person)</span>"</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greetOne = greet(person: <span class="string">"Kwai"</span>)</span><br><span class="line"><span class="keyword">let</span> greetTwo = greet(person: <span class="number">2018</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = person + <span class="string">" Hello"</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greet3 = greet(<span class="string">"Kwai"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person:String,other:String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> greeting =  <span class="string">"Hello "</span> + person + <span class="string">" and "</span> + other</span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greet4 = greet(person: <span class="string">"Kwai"</span>, other: <span class="string">"KuaiShou"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person:String,<span class="number">_</span> other:String)</span></span> -&gt; (one:<span class="type">String</span>,two:<span class="type">String</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> greeting1 =  <span class="string">"Hello "</span> + person</span><br><span class="line">    <span class="keyword">let</span> greeting2 =  <span class="string">"Hello "</span> + other</span><br><span class="line">    <span class="keyword">return</span> (greeting1,greeting2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>类似oc的block，但是更加的简洁。比如Array里面的sort，函数接受一个两个参数的闭包函数，进行排序。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Chris"</span>,<span class="string">"Alex"</span>,<span class="string">"Ewa"</span>,<span class="string">"Barry"</span>,<span class="string">"Daniella"</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backward</span><span class="params">(<span class="number">_</span> s1:String,<span class="number">_</span> s2:String)</span></span> -&gt;<span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">let</span> sortedNames = names.sorted(by: backward)</span><br><span class="line"><span class="comment">// 尾随闭包 当最后一个参数是函数的时候</span></span><br><span class="line"><span class="keyword">let</span> sorted = names.sorted &#123; (st1, st2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> st1 &gt; st2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符函数</span></span><br><span class="line"><span class="keyword">let</span> reversedNames = names.sorted(by: &gt;)</span><br></pre></td></tr></table></figure></p>
<h3 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h3><p>oc的block能够获取到作用域外的函数，当然block 有能。如果一个值没有改变，Swift 可能会使用这个值的拷贝而不是捕获。捕获值的最常见的情形就是内联函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nestedMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> increase = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> incrementer: ()-&gt;() =  &#123;</span><br><span class="line">    <span class="comment">//    捕获 才是真正的捕获</span></span><br><span class="line">        increase = increase + <span class="number">1</span></span><br><span class="line">        <span class="comment">// st 只是拷贝了st 的值</span></span><br><span class="line">        <span class="built_in">print</span>(st)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementerMethods</span><span class="params">()</span></span> &#123;</span><br><span class="line">        incrementer()</span><br><span class="line">    &#125;</span><br><span class="line">    incrementer()</span><br><span class="line">    incrementerMethods()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> copyOne = incrementer</span><br><span class="line">    copyOne()</span><br><span class="line">    <span class="built_in">print</span>(increase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>当闭包作为一个实际参数(就是有引用，改变等操作)传递给一个函数的时候，我们就说这个闭包逃逸了，因为它可以在函数返回之后被调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var completionHandlers: [() -&gt; Void] = []</span><br><span class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line">func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    var x = 10</span><br><span class="line">    func doSomething() &#123;</span><br><span class="line">        // 这两者的区别 引用和传值的区别</span><br><span class="line">        someFunctionWithEscapingClosure &#123; self.x = 100 &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x = 200 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子可以看出，逃逸closure 捕获的是引用，因为他不知道closure何时被调用，而非逃逸型closure捕获的是值。因为他立马被调用。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>swift的枚举，简直不要太好用了.每个类型都可以关联值.可以通过switch语句来获取到相应的关联值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> upc (<span class="type">Int</span>,<span class="type">Int</span>,<span class="type">Int</span>,<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> upcode = <span class="type">Barcode</span>.upc(<span class="number">12</span>, <span class="number">13</span>, <span class="number">67</span>, <span class="number">78</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> upcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .upc( x,y,<span class="number">_</span>,<span class="number">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(x+y)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和oc版的不同，swift版，不仅可以对应一个整数类型，可以对应任何可hash类型的值，并且添加方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">code</span>:<span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> qrcode = <span class="string">"qrCode"</span></span><br><span class="line">    <span class="keyword">case</span> simcode = <span class="string">"simcode"</span></span><br><span class="line">    <span class="comment">// 可以添加方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showCode</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .qrcode:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类和struct"><a href="#类和struct" class="headerlink" title="类和struct"></a>类和struct</h2><p>在swift 上，struct被提高到很高的地位，在oc中，你基本上不会用struct去声明数据类型。而在swift中，struct基本上和类没有差别。他们都具有</p>
<ol>
<li>定义属性用来存储值；</li>
<li>定义方法用于提供功能；</li>
<li>定义下标脚本用来允许使用下标语法访问值；</li>
<li>定义初始化器用于初始化状态；</li>
<li>可以被扩展来默认所没有的功能；</li>
<li>遵循协议来针对特定类型提供标准功能。</li>
</ol>
<p>类有而结构体没有的额外功能</p>
<ol>
<li>继承允许一个类继承另一个类的特征;</li>
<li>类型转换允许你在运行检查和解释一个类实例的类型；</li>
<li>反初始化器允许一个类实例释放任何其所被分配的资源；</li>
<li>引用计数允许不止一个对类实例的引用。</li>
</ol>
<p><strong>struct 是值类型 类是引用类型</strong>,对于两者的选择，应该遵循以下的要求</p>
<ol>
<li>结构体的主要目的是为了封装一些相关的简单数据值；</li>
<li>当你在赋予或者传递结构实例时，有理由需要封装的数据值被拷贝而不是引用；</li>
<li>任何存储在结构体中的属性是值类型，也将被拷贝而不是被引用；</li>
<li>结构体不需要从一个已存在类型继承属性或者行为。</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>swift中具有两种属性，存储属性和计算属性。存储属性会存储常量或变量作为实例的一部分，反之计算属性会计算（而不是存储）值。 对于类来说，初始化函数必须对每个存储属性分配初始值，不然编译阶段就会被报错。对于属性，我们可以重写get，set方法，也可以通过willSet，didSet在属性进行变化的同时进行一些操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> birth = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> day:<span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        birth = newValue * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birth/<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    willSet</span></span><br><span class="line"><span class="comment">//    didSet</span></span><br><span class="line"><span class="keyword">var</span> month:<span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> oldValue1 = oldValue &#123;</span><br><span class="line">            day = day + oldValue1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，值类型属性不能被自身的实例方法修改。如果实例方法要修改属性的值，那么这个方法需要被标记为<code>mutating</code>.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">//     在实例方法里修改实例变量 需要加上 mutating</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span><span class="params">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="下标函数"><a href="#下标函数" class="headerlink" title="下标函数"></a>下标函数</h3><p>swift 为类和结构体提供了下标访问属性的方法。重写<code>subscript</code>方法，那么就可以像访问数组那样去访问实例对象了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> feeds:[<span class="type">Feed</span>] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Feed</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; feeds.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> feeds[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> model = <span class="type">ViewModel</span>()</span><br><span class="line"><span class="keyword">let</span> feed1 = <span class="type">Feed</span>(photoId: <span class="string">"1234"</span>)</span><br><span class="line"><span class="keyword">let</span> feed2 = <span class="type">Feed</span>(photoId: <span class="string">"234"</span>)</span><br><span class="line"><span class="keyword">let</span> feed3 = <span class="type">Feed</span>(photoId: <span class="string">"34"</span>)</span><br><span class="line"><span class="keyword">let</span> feed4 = <span class="type">Feed</span>(photoId: <span class="string">"4"</span>)</span><br><span class="line"></span><br><span class="line">model.feeds.append(feed1)</span><br><span class="line">model.feeds.append(feed2)</span><br><span class="line">model.feeds.append(feed3)</span><br><span class="line">model.feeds.append(feed4)</span><br><span class="line"><span class="built_in">print</span>(model[<span class="number">1</span>]?.photoId)</span><br></pre></td></tr></table></figure>
<h4 id="属性重载"><a href="#属性重载" class="headerlink" title="属性重载"></a>属性重载</h4><blockquote>
<p>你可以通过在你的子类重写里为继承而来的只读属性添加Getter和Setter来把它用作可读写属性。但是，你不能把一个继承而来的可读写属性表示为只读属性。</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>为每个属性提供初始值，不提供将会报错</strong></p>
<h3 id="始化器"><a href="#始化器" class="headerlink" title="始化器"></a>始化器</h3><p> swift 提供两种类型的初始化器，指定初始化器和便捷初始化器。需要满足以下的规则。指定初始化器需要对所有存储属性提供初始值。而便捷初始化器最终都需要调用一个指定初始化器来初始化所有的值。他们需要满足</p>
<ol>
<li>指定初始化器必须从它的直系父类调用指定初始化器。</li>
<li>便捷初始化器必须从相同的类里调用另一个初始化器。</li>
<li>便捷初始化器最终必须调用一个指定初始化器。</li>
</ol>
<p>对于指定初始化器必须向上委托。意思就是子类的指定初始化器，必须调用父类的指定初始化器。这样所有的存储属性都将被赋值。而便捷初始化器必须总是横向委托，便捷初始化器横向的调用便捷初始化器，最终会调用指定初始化器来完成所有存储属性的值的初始化。</p>
<p>对于Swift，初始化过程分为两个阶段。在第一个阶段，每一个存储属性被引入类为分配了一个初始值。一旦每个存储属性的初始状态被确定，第二个阶段就开始了，每个类都有机会在新的实例准备使用之前来定制它的存储属性。 对于结构体，会为每个属性提供一个默认的初始化器。这个默认的初始化器会对每个属性都进行赋值操作。</p>
<h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><p>有些人说swift简单，每次遇到optional值就强制解包，这当然就变得简单的多了，但相应的就变得不安全了。比如如下场景<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addressName</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Kwai"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> address:<span class="type">Address</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">let</span> add = <span class="type">Address</span>()</span><br><span class="line">p1.address = add;</span><br><span class="line"><span class="keyword">let</span> addName = p1.address?.addressName()</span><br></pre></td></tr></table></figure></p>
<p>p1对象可能不存在一个address。如果不存在address,那么他相应的<code>addressName</code>方法也不存在了。所以可选链保证了安全性。上述<code>addName</code>变量是一个optional的string，就是说只要在可选链上，在一个optional变量之后的所有值都是一个optional值。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong><em>Swift 枚举是典型的为一组相关错误条件建模的完美配适类型，关联值还允许错误错误通讯携带额外的信息。</em></strong> <code>do-catch</code> 语句来处理错误 <code>try</code> 关键字——或者 try? 或 try! 变体——放在调用函数、方法或者会抛出错误的初始化器代码之前。错误处理改变了程序执行流程，让程序进入catch层，但是有时候需要在退出之前做一些处理操作，这时候可以使用<code>defer</code>来使用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory = [</span><br><span class="line">        <span class="string">"Candy Bar"</span>: <span class="number">7</span>,</span><br><span class="line">        <span class="string">"Chips"</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="string">"Pretzels"</span>: <span class="number">9</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vend</span><span class="params">(itemNamed name: String)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item = inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item &lt;= coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class="string">"<span class="subst">\(<span class="number">7</span> - coinsDeposited)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"always be exclute"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Dispensing <span class="subst">\(name)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 defer语句来在代码离开当前代码块前执行语句合集。这个语句允许在以任何方式离开当前代码块前执行必须要的清理工作——无论是因为抛出了错误还是因为 return或者 break这样的语句。比如，你可以使用 defer语句来保证文件描述符都关闭并且手动指定的内存到被释放。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>下面的例子<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Media</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>:<span class="title">Media</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> artess:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>,artess:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.artess = artess</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span>:<span class="title">Media</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> singer:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>,singer:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.singer = singer</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> movie = <span class="type">Movie</span>(name: <span class="string">"雷神"</span>, artess: <span class="string">"xiao lei"</span>)</span><br><span class="line"><span class="keyword">let</span> movie2 = <span class="type">Movie</span>(name: <span class="string">"雷神1"</span>, artess: <span class="string">"xiao lei1"</span>)</span><br><span class="line"><span class="keyword">let</span> movie3 = <span class="type">Movie</span>(name: <span class="string">"雷神2"</span>, artess: <span class="string">"xiao lei2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> music1 = <span class="type">Music</span>(name: <span class="string">"爱"</span>, singer: <span class="string">"jj"</span>)</span><br><span class="line"><span class="keyword">let</span> music2 = <span class="type">Music</span>(name: <span class="string">"爱爱"</span>, singer: <span class="string">"jj"</span>)</span><br><span class="line"><span class="keyword">let</span> music3 = <span class="type">Music</span>(name: <span class="string">"爱爱爱"</span>, singer: <span class="string">"jj"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itmes = [movie,music1,movie3,movie2,music2,music3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> itmes &#123;</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Music</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"music,<span class="subst">\(item.name)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到自动类型推断，将items变量推断为<code>Array&lt;Media&gt;</code>。 其实当一个父类指针指指向了一个子类的实例，遇到这种情况时可以尝试使用类型转换操作符（ as? 或 as! ）将它向下类型转换至其子类类型。 配合上if let as? 可以很好的进行类型转换。如果类型转换失败， as? 就会返回nil来结束这个类型转换。<br>对于类型转换，不得不说的是两个任意类型<code>AnyObject</code>,<code>Any</code></p>
<ul>
<li><code>AnyObject</code>可以表示任何class类型的实例。</li>
<li><code>Any</code>可以表示任何类型，包括函数类型。</li>
</ul>
<p>在 Swift中,编译器不仅不会对 <code>AnyObject</code> 实例的方法调用做出检查，甚至对于<code>AnyObject</code>的所有方法调用都会返回<code>Optional</code>的结果。 上面的例子<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aAnyArray:[<span class="type">AnyObject</span>] = []</span><br><span class="line">aAnyArray.append(music1)</span><br><span class="line">aAnyArray.append(movie2)</span><br><span class="line"><span class="comment">//aAnyArray.append("aaa") string是值类型，所以会报错，但是用Any就没有问题了</span></span><br><span class="line"><span class="keyword">var</span> anyArray:[<span class="type">Any</span>] = []</span><br><span class="line">anyArray.append(music1)</span><br><span class="line">anyArray.append(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="extension"><a href="#extension" class="headerlink" title="extension"></a>extension</h2><p>extension为现有的类、结构体、枚举类型、或协议添加了新功能。这也包括了为无访问权限的源代码扩展类型的能力（即所谓的逆向建模）。扩展和Objective-C 中的分类类似。（与Objective-C的分类不同的是，Swift的扩展没有名字。）<br>但是extension又比Category更加的强大，具体表现在以下几点</p>
<ol>
<li>添加计算实例属性和计算类型属性；</li>
<li>定义实例方法和类型方法；</li>
<li>提供新初始化器；</li>
<li>定义下标；</li>
<li>定义和使用新内嵌类型；</li>
<li>使现有的类型遵循某协议，使代码更具有可读性</li>
<li>扩展能为类添加新的便捷初始化器，但是不能为类添加指定初始化器或反初始化器。指定初始化器和反初始化器 必须由原来类的实现提供。原因其实很简单，扩展不能添加新的存储属性，是因为指定初始化器需要给每个属性分配内存和初始化默认值，在扩展里添加存储属性的话，就不能够保证原来的指定初始化器能够给所有的属性提供默认值。</li>
</ol>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议可被<strong><em>类、结构体、或枚举类型</em></strong>采纳以提供所需功能的具体实现。满足了协议中需求的任意类型都叫做遵循了该协议。</p>
<h3 id="协议属性"><a href="#协议属性" class="headerlink" title="协议属性"></a>协议属性</h3><p>协议可以要求所有遵循该协议的类型提供特定名字和类型的实例属性或类型属性。协议并不会具体说明属性是储存型属性还是计算型属性。它只具体要求属性有特定的名称和类型。协议同时要求一个属性必须明确是可读的或可读的和可写的。</p>
<blockquote>
<p>总结一下就是 协议属性 只要实现协议的对象有个同名和同类型的属性就行。<br>比如<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">TextRepresentable</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText = <span class="keyword">self</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + itemsAsText.joined(separator: <span class="string">", "</span>) + <span class="string">"]"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的例子<code>Array</code>遵循了<code>TextRepresentable</code>协议，<code>TextRepresentable</code>协议中有个协议属性<code>var textualDescription: String</code> ,所以只要Array实现了这个属性就行。</p>
<h3 id="可选协议"><a href="#可选协议" class="headerlink" title="可选协议"></a>可选协议</h3><p>oc 遵循协议，不需要全部都实现协议里所有的方法。但是对于swift 来说，必须都实现其中的所有方法，不然还是会遇到编译错误。这里就有两种方式来解决问题</p>
<h4 id="使用-objc"><a href="#使用-objc" class="headerlink" title="使用@objc"></a>使用@objc</h4><p>@objc修饰符，让swift对象具有动态性，其实也就是让他走oc对象的那一套，在运行时决定，编译器就不会在静态的检查类型了。通过给协议添加@objc头部，那么每个方法可以添加<code>optional</code> 来实现可选 如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(forCount <span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过协议扩展，来提供一个默认方法"><a href="#通过协议扩展，来提供一个默认方法" class="headerlink" title="通过协议扩展，来提供一个默认方法"></a>通过协议扩展，来提供一个默认方法</h4><p>之前说了extension可以扩展类，结构体，enum。当然也可以扩展协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CounterDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(forCount <span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Counter</span>:<span class="title">CounterDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有这个会报错，说Counter未遵循CounterDelegate 协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CounterDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(forCount <span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fixedIncrement:<span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码，如果没有扩展协议，那么会报Counter未遵循CounterDelegate 协议的编译错误。</p>
<h3 id="协议扩展添加限制"><a href="#协议扩展添加限制" class="headerlink" title="协议扩展添加限制"></a>协议扩展添加限制</h3><p>可以通过where语句，对扩展进行一定的限制，比如<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Iterator</span>.<span class="title">Element</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText = <span class="keyword">self</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + itemsAsText.joined(separator: <span class="string">", "</span>) + <span class="string">"]"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码为<code>Collection</code>协议扩展了一个计算属性来返回一个字符串，但是只针对<code>Collection</code>存储的元素都遵循<code>TextRepresentable</code>协议的<code>Collection</code>。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Swift的泛型和其他语言的泛型并没有什么太大的差异。但是在使用上很友好。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a:<span class="keyword">inout</span> T,<span class="number">_</span> b:<span class="keyword">inout</span> T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如我声明了一个交换值的函数，在调用的时候，可以直接使用,不用去指定泛型的具体的类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapTwoValues(&amp;someInt, &amp;anotherInt)</span><br></pre></td></tr></table></figure>
<h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>定义一个协议时，有时在协议定义里声明一个或多个关联类型是很有用的。关联类型给协议中用到的类型一个占位符名称。直到采纳协议时，才指定用于该关联类型的实际类型。关联类型通过<code>associatedtype</code>关键字指定。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">ItemType</span></span><br><span class="line">    associatedtype <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: ItemType)</span></span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在遵循协议的类，结构体内用<code>typealias ItemType = Int</code> 来指定关联类型的实际类型</p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>Swift 的访问控制模型基于模块和源文件的概念。也就是说这些访问限制符，针对源文件和模块。</p>
<ul>
<li><code>Open</code>访问和<code>public</code>访问。允许实体被定义模块中的任意源文件访问，同样可以被另一模块的源文件通过导入该定义模块来访问。在指定框架的公共接口时，通常使用<code>open</code>或<code>public</code>访问。</li>
<li><code>Internal</code> 访问 。允许实体被定义模块中的任意源文件访问，但不能被该模块之外的任何源文件访问。通常在定义应用程序或是框架的内部结构时使用。</li>
<li><code>file-private</code>访问。将实体的使用限制于当前定义源文件中。当一些细节在整个文件中使用时，使用<code>file-private</code>访问隐藏特定功能的实现细节。</li>
<li><code>private</code>访问 将实体的使用限制于封闭声明中。当一些细节仅在单独的声明中使用时，使用<code>private</code>访问隐藏特定功能的实现细节。</li>
</ul>
<blockquote>
<p><code>open</code>访问仅适用于类和类成员，它与<code>public</code>访问区别主要是：public不能在模块外被继承，显式地标记类为open 意味着你考虑过其他模块使用该类作为父类对代码的影响，并且相应地设计了类的代码。</p>
</blockquote>
<p>对于属性，也可以设置只读，只写操作，防止外界调用修改这个属性<br><code>fileprivate(set) , private(set)</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是<code>the swift programming language</code> 读书笔记，能够快速了解到swift的一些基本概念。Swift经过4年的发展，已经稳定了很多，ABI有比较稳定，到明年年初Swift5的时候，基本上不会再经历一个版本重新学一次的尴尬地步。之后准备读<code>functional-swift</code>这本书，提升一下自己的编程思维</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-07-20</span><i class="fa fa-comment-o"></i><a href="/2018/07/20/Swift4-2/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/tags/Swift-读书笔记/" title="Swift , 读书笔记">Swift , 读书笔记 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,kyleruan.github.io/2018/07/20/Swift4-2/,Dev &amp;&amp; Football,the swift programming language swift 4.2 读书笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/09/18/经典排序算法/" title="经典排序算法">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'kyleruan';
var disqus_identifier = '2018/07/20/Swift4-2/';
var disqus_title = 'the swift programming language swift 4.2 读书笔记';
var disqus_url = 'kyleruan.github.io/2018/07/20/Swift4-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>